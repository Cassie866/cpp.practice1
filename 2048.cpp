项目背景
 
2048是一个风靡全球的益智类小游戏，通过上下左右控制来合并盘子里的数字，直到盘子里出现2048。
 

原版体验地址 http://gabrielecirulli.github.io/2048/
 
依赖库
 

     
    linux: apt-get install libncurses5-dev 
    Mac: brew install ncurses 
    Windows: 
         
    安装编译器MinGW,https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/ 下载mingw-w64-install.exe 5.0.4版本,解压到本地目录，例如 C:\mingw64,然后把C:\mingw64\bin 加入到系统设置的路径里,打开命令行控制台输入g++，确认有这个命令以保证安装是成功 
    编译pdcurses库,https://sourceforge.net/projects/pdcurses/files/pdcurses/3.6/pdcurs36.zip/download 下载pdcurses后解压到C:\pdcurs36目录，命令行控制台cd到 C:\pdcurs36\wincon目录，运行 mingw32-make 命令编译pdcurses库，编译成功后目录下有多个demo的exe文件以及一个pdcurses.a文件，这个文件是库文件。 
      

 
开发要点

    一次只能合并相邻的两个数字，例如 [2 2 2 2] ，向右合并以后是 [空 空 4 4] ，不是 [空 空 空 8] 
    每次合并的时候，合并方向优先级高，例如 [空 2 2 2]，向右合并以后是 [空 空 2 4]，不是 [空 空 4 2] 
    判断游戏胜利或者失败 
    每次合并以后随机新出4的概率10% 

 
编译命令
  
    Linux/Mac: g++ 2048.cpp -l ncurses -o 2048 
    Windows: g++ 2048.cpp C:\pdcurs36\wincon\pdcurses.a -I C:\pdcurs36\ -o 2048 

 
开发步骤
  
    引入curses库 
    绘制游戏界面 
    游戏状态切换 
    重启初始化游戏 
    向左移动 
    向其他方向移动 
    游戏胜负判定 

 
扩展
 

记录最高分
 
 
 
 
 
引入curses库
#include <string> 
#include <vector> 
#include <cstdlib> 
#include <cstdio> 
#include <ctime> 
#include <curses.h> 
using namespace std; 
void initialize() 
{     // ncurses初始化     
initscr();     // 按键不需要输入回车直接交互    
 cbreak();     // 按键不显示  
 noecho();     // 隐藏光标   
 curs_set(0);     // 随机数   
 srand(time(NULL)); 
 }
 void shutdown() 
 {     // ncurses清理     
 endwin(); 
 } 
 int main() 
 {     
 initialize(); 
 char ch = 'n';    
 do 
 {  
 move(5, 5);  
 addch(ch);    
 mvprintw(2, 2, "https://www.nowcoder.com");    
 ch = getch();  
 }
 while (ch != 'Q' && ch != 'q'); 
 shutdown();    
 return 0; 
 }
 
 
 绘制界面
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 class Game2048 { public:     Game2048() {         setTestData();     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << i << j;                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N]; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     char ch = 'n';     do {         game.draw();         ch = getch();     } while (ch != 'Q' && ch != 'q');     shutdown();     return 0; }


状态切换
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 // 游戏状态 #define S_FAIL 0 #define S_WIN 1 #define S_NORMAL 2 #define S_QUIT 3 class Game2048 { public:     Game2048() : status(S_NORMAL) {         setTestData();     }     int getStatus() { return status; }     // 处理按键     void processInput() {         char ch = getch();         // 转化成大写         if (ch >= 'a' && ch <= 'z') {             ch -= 32;         }         if (ch == 'Q') {             status = S_QUIT;         } else {             // 在各种状态中间遍历，测试界面             status = (status + 1) % 3;         }     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");         if (status == S_WIN) {             mvprintw( N, 5 * N / 2 - 1, " YOU WIN,PRESS R TO CONTINUE ");         } else if (status == S_FAIL) {             mvprintw( N, 5 * N / 2 - 1, " YOU LOSE,PRESS R TO CONTINUE ");         }     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << i << j;                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N];     int status; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     do {         game.draw();         game.processInput();     } while (S_QUIT != game.getStatus());     shutdown();     return 0; }


重启初始化游戏
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 // 游戏状态 #define S_FAIL 0 #define S_WIN 1 #define S_NORMAL 2 #define S_QUIT 3 class Game2048 { public:     Game2048() : status(S_NORMAL) {         setTestData();     }     int getStatus() { return status; }     // 处理按键     void processInput() {         char ch = getch();         // 转化成大写         if (ch >= 'a' && ch <= 'z') {             ch -= 32;         }         if (ch == 'Q') {             status = S_QUIT;         } else if (ch == 'R') {             restart();         } else {             // 在各种状态中间遍历，测试界面             status = (status + 1) % 3;         }     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");         if (status == S_WIN) {             mvprintw( N, 5 * N / 2 - 1, " YOU WIN,PRESS R TO CONTINUE ");         } else if (status == S_FAIL) {             mvprintw( N, 5 * N / 2 - 1, " YOU LOSE,PRESS R TO CONTINUE ");         }     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << i << j;                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 重新开始     void restart() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 0;             }         }         randNew();         randNew();         status = S_NORMAL;     }     // 随机产生一个新的数字     bool randNew() {         vector<int> emptyPos;         // 把空位置先存起来         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] == 0) {                     emptyPos.push_back(i * N + j);                 }             }         }         if (emptyPos.size() == 0) {             return false;         }         // 随机找个空位置         int value = emptyPos[rand() % emptyPos.size()];         // 10%的概率产生4         data[value / N][value % N] = rand() % 10 == 1 ? 4 : 2;         return true;     }     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N];     int status; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     do {         game.draw();         game.processInput();     } while (S_QUIT != game.getStatus());     shutdown();     return 0; }


向左移动

#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 // 游戏状态 #define S_FAIL 0 #define S_WIN 1 #define S_NORMAL 2 #define S_QUIT 3 class Game2048 { public:     Game2048() : status(S_NORMAL) {         setTestData();     }     int getStatus() { return status; }     // 处理按键     void processInput() {         char ch = getch();         // 转化成大写         if (ch >= 'a' && ch <= 'z') {             ch -= 32;         }         if (status == S_NORMAL) {             if (ch == 'A') {                 moveLeft();             }         }         if (ch == 'Q') {             status = S_QUIT;         } else if (ch == 'R') {             restart();         }     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");         if (status == S_WIN) {             mvprintw( N, 5 * N / 2 - 1, " YOU WIN,PRESS R TO CONTINUE ");         } else if (status == S_FAIL) {             mvprintw( N, 5 * N / 2 - 1, " YOU LOSE,PRESS R TO CONTINUE ");         }     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << (i + j);                 data[i][j] = 2 << (1 + rand() % 7);                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 向左边移动     void moveLeft() {         for (int i = 0; i < N; ++i) {             // 逐行处理             // 如果两个数字一样，当前可写入的位置             int currentWritePos = 0;             int lastValue = 0;             for (int j = 0; j < N; ++j) {                 if (data[i][j] == 0) {                     continue;                 }                 if (lastValue == 0) {                     lastValue = data[i][j];                 } else {                     if (lastValue == data[i][j]) {                         data[i][currentWritePos] = lastValue * 2;                         lastValue = 0;                     } else {                         data[i][currentWritePos] = lastValue;                         lastValue = data[i][j];                     }                     ++currentWritePos;                 }                 data[i][j] = 0;             }             if (lastValue != 0) {                 data[i][currentWritePos] = lastValue;             }         }     }     // 重新开始     void restart() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 0;             }         }         randNew();         randNew();         status = S_NORMAL;                 // 测试moveLeft         setTestData();     }     // 随机产生一个新的数字     bool randNew() {         vector<int> emptyPos;         // 把空位置先存起来         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] == 0) {                     emptyPos.push_back(i * N + j);                 }             }         }         if (emptyPos.size() == 0) {             return false;         }         // 随机找个空位置         int value = emptyPos[rand() % emptyPos.size()];         // 10%的概率产生4         data[value / N][value % N] = rand() % 10 == 1 ? 4 : 2;         return true;     }     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N];     int status; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     do {         game.draw();         game.processInput();     } while (S_QUIT != game.getStatus());     shutdown();     return 0; }


向其他方向移动
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 // 游戏状态 #define S_FAIL 0 #define S_WIN 1 #define S_NORMAL 2 #define S_QUIT 3 class Game2048 { public:     Game2048() : status(S_NORMAL) {         setTestData();     }     int getStatus() { return status; }     // 处理按键     void processInput() {         char ch = getch();         // 转化成大写         if (ch >= 'a' && ch <= 'z') {             ch -= 32;         }         if (status == S_NORMAL) {             bool updated = false;             if (ch == 'A') {                 updated = moveLeft();             } else if (ch == 'S') {                 // 向下移动 = 旋转270度，向左移动，再旋转90度                 rotate();                 rotate();                 rotate();                 updated = moveLeft();                 rotate();             } else if (ch == 'D') {                 rotate();                 rotate();                 updated = moveLeft();                 rotate();                 rotate();             } else if (ch == 'W') {                 rotate();                 updated = moveLeft();                 rotate();                 rotate();                 rotate();             }             if (updated) {                 randNew();             }         }         if (ch == 'Q') {             status = S_QUIT;         } else if (ch == 'R') {             restart();         }     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");         if (status == S_WIN) {             mvprintw( N, 5 * N / 2 - 1, " YOU WIN,PRESS R TO CONTINUE ");         } else if (status == S_FAIL) {             mvprintw( N, 5 * N / 2 - 1, " YOU LOSE,PRESS R TO CONTINUE ");         }     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << (i + j);                 data[i][j] = 2 << (1 + rand() % 7);                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 向左边移动, 返回值表示盘面是否有发生变化     bool moveLeft() {         int tmp[N][N];         for (int i = 0; i < N; ++i) {             // 逐行处理             // 如果两个数字一样，当前可写入的位置             int currentWritePos = 0;             int lastValue = 0;             for (int j = 0; j < N; ++j) {                 tmp[i][j] = data[i][j];                 if (data[i][j] == 0) {                     continue;                 }                 if (lastValue == 0) {                     lastValue = data[i][j];                 } else {                     if (lastValue == data[i][j]) {                         data[i][currentWritePos] = lastValue * 2;                         lastValue = 0;                     } else {                         data[i][currentWritePos] = lastValue;                         lastValue = data[i][j];                     }                     ++currentWritePos;                 }                 data[i][j] = 0;             }             if (lastValue != 0) {                 data[i][currentWritePos] = lastValue;             }         }         // 看看是否发生了变化         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] != tmp[i][j]) return true;             }         }         return false;     }     // 矩阵逆时针旋转90度     void rotate() {         int tmp[N][N] = {0};         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 tmp[i][j] = data[j][N - 1 - i];             }         }         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = tmp[i][j];             }         }     }     // 重新开始     void restart() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 0;             }         }         randNew();         randNew();         status = S_NORMAL;     }     // 随机产生一个新的数字     bool randNew() {         vector<int> emptyPos;         // 把空位置先存起来         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] == 0) {                     emptyPos.push_back(i * N + j);                 }             }         }         if (emptyPos.size() == 0) {             return false;         }         // 随机找个空位置         int value = emptyPos[rand() % emptyPos.size()];         // 10%的概率产生4         data[value / N][value % N] = rand() % 10 == 1 ? 4 : 2;         return true;     }     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N];     int status; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     do {         game.draw();         game.processInput();     } while (S_QUIT != game.getStatus());     shutdown();     return 0; }

游戏胜负判定

#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 // 胜利条件 #define TARGET 2048 // 游戏状态 #define S_FAIL 0 #define S_WIN 1 #define S_NORMAL 2 #define S_QUIT 3 class Game2048 { public:     Game2048() : status(S_NORMAL) {         setTestData();     }     int getStatus() { return status; }     // 处理按键     void processInput() {         char ch = getch();         // 转化成大写         if (ch >= 'a' && ch <= 'z') {             ch -= 32;         }         if (status == S_NORMAL) {             bool updated = false;             if (ch == 'A') {                 updated = moveLeft();             } else if (ch == 'S') {                 // 向下移动 = 旋转270度，向左移动，再旋转90度                 rotate();                 rotate();                 rotate();                 updated = moveLeft();                 rotate();             } else if (ch == 'D') {                 rotate();                 rotate();                 updated = moveLeft();                 rotate();                 rotate();             } else if (ch == 'W') {                 rotate();                 updated = moveLeft();                 rotate();                 rotate();                 rotate();             }             if (updated) {                 randNew();                 if (isOver()) {                     status = S_FAIL;                 }             }         }         if (ch == 'Q') {             status = S_QUIT;         } else if (ch == 'R') {             restart();         }     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");         if (status == S_WIN) {             mvprintw( N, 5 * N / 2 - 1, " YOU WIN,PRESS R TO CONTINUE ");         } else if (status == S_FAIL) {             mvprintw( N, 5 * N / 2 - 1, " YOU LOSE,PRESS R TO CONTINUE ");         }     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << (i + j);                 // data[i][j] = 2 << (1 + rand() % 7);                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 判断游戏已经结束     bool isOver() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 // 有空位或者相邻有一样的都可以继续                 if ((j + 1 < N) && (data[i][j] * data[i][j+1] == 0 || data[i][j] == data[i][j+1])) return false;                 if ((i + 1 < N) && (data[i][j] * data[i+1][j] == 0 || data[i][j] == data[i+1][j])) return false;             }         }         return true;     }     // 向左边移动, 返回值表示盘面是否有发生变化     bool moveLeft() {         int tmp[N][N];         for (int i = 0; i < N; ++i) {             // 逐行处理             // 如果两个数字一样，当前可写入的位置             int currentWritePos = 0;             int lastValue = 0;             for (int j = 0; j < N; ++j) {                 tmp[i][j] = data[i][j];                 if (data[i][j] == 0) {                     continue;                 }                 if (lastValue == 0) {                     lastValue = data[i][j];                 } else {                     if (lastValue == data[i][j]) {                         data[i][currentWritePos] = lastValue * 2;                         lastValue = 0;                         if (data[i][currentWritePos] == TARGET) {                             status = S_WIN;                         }                     } else {                         data[i][currentWritePos] = lastValue;                         lastValue = data[i][j];                     }                     ++currentWritePos;                 }                 data[i][j] = 0;             }             if (lastValue != 0) {                 data[i][currentWritePos] = lastValue;             }         }         // 看看是否发生了变化         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] != tmp[i][j]) return true;             }         }         return false;     }     // 矩阵逆时针旋转90度     void rotate() {         int tmp[N][N] = {0};         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 tmp[i][j] = data[j][N - 1 - i];             }         }         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = tmp[i][j];             }         }     }     // 重新开始     void restart() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 0;             }         }         randNew();         randNew();         status = S_NORMAL;     }     // 随机产生一个新的数字     bool randNew() {         vector<int> emptyPos;         // 把空位置先存起来         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] == 0) {                     emptyPos.push_back(i * N + j);                 }             }         }         if (emptyPos.size() == 0) {             return false;         }         // 随机找个空位置         int value = emptyPos[rand() % emptyPos.size()];         // 10%的概率产生4         data[value / N][value % N] = rand() % 10 == 1 ? 4 : 2;         return true;     }     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N];     int status; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     do {         game.draw();         game.processInput();     } while (S_QUIT != game.getStatus());     shutdown();     return 0; }


全部？
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <ctime> #include <curses.h> using namespace std; // 格子数 #define N 4 // 每个格子的字符长度 #define WIDTH 5 // 胜利条件 #define TARGET 2048 // 游戏状态 #define S_FAIL 0 #define S_WIN 1 #define S_NORMAL 2 #define S_QUIT 3 class Game2048 { public:     Game2048() : status(S_NORMAL) {         setTestData();     }     int getStatus() { return status; }     // 处理按键     void processInput() {         char ch = getch();         // 转化成大写         if (ch >= 'a' && ch <= 'z') {             ch -= 32;         }         if (status == S_NORMAL) {             bool updated = false;             if (ch == 'A') {                 updated = moveLeft();             } else if (ch == 'S') {                 // 向下移动 = 旋转270度，向左移动，再旋转90度                 rotate();                 rotate();                 rotate();                 updated = moveLeft();                 rotate();             } else if (ch == 'D') {                 rotate();                 rotate();                 updated = moveLeft();                 rotate();                 rotate();             } else if (ch == 'W') {                 rotate();                 updated = moveLeft();                 rotate();                 rotate();                 rotate();             }             if (updated) {                 randNew();                 if (isOver()) {                     status = S_FAIL;                 }             }         }         if (ch == 'Q') {             status = S_QUIT;         } else if (ch == 'R') {             restart();         }     }     // 绘制游戏界面     void draw() {         // 清理屏幕         clear();         // 居中偏移         const int offset = 12;         for (int i = 0; i <= N; ++i) {             for (int j = 0; j <= N; ++j) {                 // 相交点                 drawItem(i * 2, 1 + j * WIDTH + offset, '+');                 // 竖线                 if (i != N) {                     drawItem(i * 2 + 1, 1 + j * WIDTH + offset, '|');                 }                 // 横线                 for (int k = 1; j != N && k < WIDTH; ++k) {                     drawItem(i * 2, 1 + j * WIDTH + k + offset, '-');                 }                 // 每个格子里的数                 if (i != N && j != N) {                     drawNum(i * 2 + 1, (j + 1) * WIDTH + offset, data[i][j]);                 }             }         }         // 提示文字         mvprintw(2 * N + 2, (5 * (N - 4) - 1) / 2, "W(UP),S(DOWN),A(LEFT),D(RIGHT),R(RESTART),Q(QUIT)");         mvprintw(2 * N + 3, 12 + 5 * (N - 4) / 2, "https://www.nowcoder.com");         if (status == S_WIN) {             mvprintw( N, 5 * N / 2 - 1, " YOU WIN,PRESS R TO CONTINUE ");         } else if (status == S_FAIL) {             mvprintw( N, 5 * N / 2 - 1, " YOU LOSE,PRESS R TO CONTINUE ");         }     }     // 方便调试, 随时设置数据     void setTestData() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 16 << (i + j);                 // data[i][j] = 2 << (1 + rand() % 7);                 /*                 data[i][0] = 2;                 data[i][1] = 4;                 data[i][2] = 8;                 data[i][3] = 16;*/             }         }     } private:     // 判断游戏已经结束     bool isOver() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 // 有空位或者相邻有一样的都可以继续                 if ((j + 1 < N) && (data[i][j] * data[i][j+1] == 0 || data[i][j] == data[i][j+1])) return false;                 if ((i + 1 < N) && (data[i][j] * data[i+1][j] == 0 || data[i][j] == data[i+1][j])) return false;             }         }         return true;     }     // 向左边移动, 返回值表示盘面是否有发生变化     bool moveLeft() {         int tmp[N][N];         for (int i = 0; i < N; ++i) {             // 逐行处理             // 如果两个数字一样，当前可写入的位置             int currentWritePos = 0;             int lastValue = 0;             for (int j = 0; j < N; ++j) {                 tmp[i][j] = data[i][j];                 if (data[i][j] == 0) {                     continue;                 }                 if (lastValue == 0) {                     lastValue = data[i][j];                 } else {                     if (lastValue == data[i][j]) {                         data[i][currentWritePos] = lastValue * 2;                         lastValue = 0;                         if (data[i][currentWritePos] == TARGET) {                             status = S_WIN;                         }                     } else {                         data[i][currentWritePos] = lastValue;                         lastValue = data[i][j];                     }                     ++currentWritePos;                 }                 data[i][j] = 0;             }             if (lastValue != 0) {                 data[i][currentWritePos] = lastValue;             }         }         // 看看是否发生了变化         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] != tmp[i][j]) return true;             }         }         return false;     }     // 矩阵逆时针旋转90度     void rotate() {         int tmp[N][N] = {0};         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 tmp[i][j] = data[j][N - 1 - i];             }         }         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = tmp[i][j];             }         }     }     // 重新开始     void restart() {         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 data[i][j] = 0;             }         }         randNew();         randNew();         status = S_NORMAL;     }     // 随机产生一个新的数字     bool randNew() {         vector<int> emptyPos;         // 把空位置先存起来         for (int i = 0; i < N; ++i) {             for (int j = 0; j < N; ++j) {                 if (data[i][j] == 0) {                     emptyPos.push_back(i * N + j);                 }             }         }         if (emptyPos.size() == 0) {             return false;         }         // 随机找个空位置         int value = emptyPos[rand() % emptyPos.size()];         // 10%的概率产生4         data[value / N][value % N] = rand() % 10 == 1 ? 4 : 2;         return true;     }     // 左上角为（0，0），在指定的位置画一个字符     void drawItem(int row, int col, char c) {         move(row, col);         addch(c);     }     // 游戏里的数字是右对齐，row, col是数字最后一位所在的位置     void drawNum(int row, int col, int num) {         while (num > 0) {             drawItem(row, col, num % 10 + '0');             num /= 10;             --col;         }     } private:     int data[N][N];     int status; }; void initialize() {     // ncurses初始化     initscr();     // 按键不需要输入回车直接交互     cbreak();     // 按键不显示     noecho();     // 隐藏光标     curs_set(0);     // 随机数     srand(time(NULL)); } void shutdown() {     // ncurses清理     endwin(); } int main() {     initialize();     Game2048 game;     do {         game.draw();         game.processInput();     } while (S_QUIT != game.getStatus());     shutdown();     return 0; }




 








